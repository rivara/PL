package practica.analyzer;
//LIBRERIAS
import java_cup.runtime.*;
import java_cup.runtime.Symbol;
import java.io.FileOutputStream;
import java.io.IOException;
import practica.objects.*;
//CONTROL DE ERRORESZ 
parser code {:

public void syntax_error (Symbol s){
	System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	System.err.println("Error recuperado");
}

public void unrecovered_syntax_error(Symbol s){
	System.err.println("Error de sintaxis no recuperable");
}
:};


//DECLARACION DE TERMINALES
// ver porque hector tiene algunos terminales definidos como String
terminal String FUNCTION,PROCEDURE, BEGIN,END,VAR,REAL,OPEN_PARENTESIS,CLOSE_PARENTESIS,POINT_SEMICOLON,
 SEMICOLON,EQUAL,PLUS,MINUS,MULTIPLICACION,DOUBLE_COLON,DIV,CONST,MOD,IDENTIFIER,NUMERIC_REAL_CONST,
 NUMERIC_INTEGER_CONST,STRING_CONST;
// terminal DOUBLE_COLON_EQUAL;
//terminal RETURN; 
//terminal VOID;
//terminal INT;
//terminal FLOAT;
//terminal IF;
//terminal THEN;
//terminal ELSE;	
//terminal WHILE;
//terminal DO;
//terminal REPEAT;
//terminal UNTIL;
//terminal FOR;
//terminal DOWNTO;
//terminal OR;
//terminal AND;
//terminal NOT;
//terminal GRETTER;
//terminal LESS;
//terminal GRETTER_EQUAL;
//terminal LESS_EQUAL;
//terminal PLUS_EQUAL;
//terminal MINUS_EQUAL;
//terminal MULTIPLICACION_EQUAL;
//terminal DIV_EQUAL;

//terminal END_COMENT;
//terminal JUMP;

//NO TERMINALES
// Top de la gramatica 
// metodo list de arraylist 
// metodo recorrer y expulsarlo en el fichero  
non terminal Programa PRG ,BLQ;
//segundo nivel
non terminal Subprograma DCLLIST,DCL,SENTLIST,SENT; 
//tercer nivel
non terminal Sentencia ASIG, PROC_CALL,FACTOR,SIMPLEVALUE,SUBPARAMLIST;
non terminal Definiciones DEFCTE, DEFVAR,DEFPROC,DEFFUN;
//cuarto nivel
non terminal Expresion CTELIST,EXP,DEFVARLIST, VARLIST,FORMAL_PARAMLIST,FORMAL_PARAM,EXPLIST;
 // ultimo nivel ¿arrays de strings?
non terminal Simbolos  SIMPVALUE,TBAS,OP,OPARIT,ID;







/*ORDENAMIENTO (rompe ambigüedad de jerarquia)*/
precedence left PLUS, MINUS,MULTIPLICACION,DIV,MOD,OPEN_PARENTESIS,CLOSE_PARENTESIS; 


//GRAMATICA

/* Ejemplo 2018
PROGRAM ::= DEFINES:p1 PARTES:p2 {:
			Programa p = new Programa();
			p.declaraciones = p1.declaraciones;
			p.funciones = p2.funciones;
			Programa.generarFichero(p.imprimir().toString());
			RESULT = p
*/

PRG ::= PRG:p  BLQ:b  {: 
Programa p = new Programa();
p.cabecera
RESULT =p } 
;
BLQ ::= DCLLIST:dc BEGIN:b SENTLIST:s END:e  {: RESULT = :} 
;

DCLLIST ::=  DCLLIST:dcl DCL:dc {: RESULT = :} |;

SENTLIST ::= SENT:s {: RESULT = :} 
|SENTLIST:sl SENT:s {: RESULT =  :} 
;

DCL ::= DEFCTE:d {: RESULT =  :}  
		| DEFVAR:dv {: RESULT =  :} 
		| DEFPROC:dp {: RESULT = :} 
		| DEFFUN:df {: RESULT = :} 
;	

DEFCTE ::=CONST:c CTELIST:ct {: RESULT =  :} 
;

CTELIST ::= IDENTIFIER:i EQUAL:e SIMPVALUE:s POINT_SEMICOLON:p{: RESULT = :} 
|CTELIST:c IDENTIFIER:i EQUAL:e SIMPVALUE:s  POINT_SEMICOLON:p{: RESULT =:} 
;

SIMPVALUE ::= NUMERIC_INTEGER_CONST:ni {: RESULT = :}
| NUMERIC_REAL_CONST:nr {: RESULT = :}
| STRING_CONST:s  {: RESULT = :}
;

DEFVAR ::= VAR:v DEFVARLIST:d POINT_SEMICOLON:p  {: RESULT =  :} 
;


DEFVARLIST ::= VARLIST:v DOUBLE_COLON:d TBAS:t  {: RESULT =  :} 
| DEFVARLIST:d POINT_SEMICOLON:p VARLIST:v DOUBLE_COLON:d TBAS:t  {: RESULT =:} 
;



VARLIST ::= IDENTIFIER:i  {: RESULT = :}
| IDENTIFIER:i  SEMICOLON:s VARLIST:v  {: RESULT =:} 
;



DEFPROC ::= PROCEDURE:p IDENTIFIER:i FORMAL_PARAMLIST:f POINT_SEMICOLON:ps BLQ:b POINT_SEMICOLON:ps{: RESULT =:} 
;

DEFFUN ::= FUNCTION:f IDENTIFIER:i FORMAL_PARAMLIST:fo DOUBLE_COLON:d TBAS:t POINT_SEMICOLON:ps BLQ:b POINT_SEMICOLON:ps{: RESULT = :} 
;

FORMAL_PARAMLIST ::= OPEN_PARENTESIS FORMAL_PARAM:f CLOSE_PARENTESIS:c {: RESULT =:} | 
;

FORMAL_PARAM ::= VARLIST:v DOUBLE_COLON:d  TBAS:t {: RESULT =:} 
| VARLIST:v DOUBLE_COLON:d TBAS:t  POINT_SEMICOLON:ps FORMAL_PARAM:f {: RESULT =  :} 
;

TBAS ::= NUMERIC_INTEGER_CONST:n {: RESULT = :}
| REAL:r {: RESULT =  :}
;

SENT ::= ASIG:a POINT_SEMICOLON:ps {: RESULT = :}
| PROC_CALL:p POINT_SEMICOLON:ps {: RESULT =  :}
;

ASIG ::= ID:i POINT_SEMICOLON:ps EXP:e {: RESULT = :}
;

ID ::= IDENTIFIER:i {: RESULT =  :}
;

EXP ::= EXP:e OP:o EXP:e  {: RESULT =  :}
| FACTOR:f  {: RESULT = :}
;

OP ::= OPARIT:o  {: RESULT =  :}
;

OPARIT ::= PLUS:p {: RESULT = :}
| MINUS:mi  {: RESULT =  :}
| MULTIPLICACION:mu {:  :}
| DIV:d  {: RESULT = :}
| MOD:m {: RESULT = :}
;

FACTOR ::= SIMPVALUE:s  {: RESULT =  :}
| OPEN_PARENTESIS:o EXP:e CLOSE_PARENTESIS:c {: RESULT = :}
| IDENTIFIER:i   SUBPARAMLIST:s  {: RESULT = :}
;

SUBPARAMLIST ::=  OPEN_PARENTESIS:o EXPLIST:e CLOSE_PARENTESIS:c  {: RESULT =  :}

;

EXPLIST ::= EXP:e  {: RESULT = new Explist(e);  parser.objCodeInitial=RESULT; :}
| EXP:e SEMICOLON:s EXPLIST:ex  {: RESULT =  :}
;
 
PROC_CALL ::= IDENTIFIER:i SUBPARAMLIST:s {: RESULT = :}
;



