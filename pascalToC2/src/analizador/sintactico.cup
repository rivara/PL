	package analizador;
//LIBRERIAS
	import java_cup.runtime.*;
	import java_cup.runtime.Symbol;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.util.ArrayList;

//CONTROL DE ERRORES 
parser code {:
 	public static ArrayList<Programa> pgrArray = new ArrayList<Programa>(); 
	public static ArrayList<Programa> blqArray = new ArrayList<Programa>(); 
	// SENTENCIAS	
	public static ArrayList<Sentencia> sentArray = new ArrayList<Sentencia>();
	public static ArrayList<SubSentencia> subsentArray = new ArrayList<SubSentencia>();
    public static ArrayList<ArrayList<SubSentencia>>expListArray = new ArrayList<ArrayList<SubSentencia>>();
	// DECLARACIONES
    public static ArrayList<Funcion> dclArray = new ArrayList<Funcion>(); 
 public static ArrayList<String> prueba = new ArrayList<String>(); 
	public static ArrayList<SubFuncion> subdclArray = new ArrayList<SubFuncion>(); 

	public static ArrayList<String> prueba = new ArrayList<String>(); 


  	public static ArrayList<String> ErroresSintacticos=new ArrayList<String>();
	public int cont = 0;
	   
	

    /**Metodo al que se llama automáticamente ante algún error sintactico.*/
    public void syntax_error(Symbol s){
        System.out.println("Error en la Linea " + (s.right+1) +" Columna "+s.left+ ". Identificador "
        +s.value + " no reconocido." );
     ErroresSintacticos.add("Error Sintactico: "+s.value.toString()+" Linea: "+(s.right+1)+";");
    }



    /**Metodo al que se llama en el momento en que ya no es posible una recuperación de
    errores.*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la Linea " + (s.right+1)+ " Columna "+s.left+". Identificador " +
        s.value + " no reconocido.");
 ErroresSintacticos.add("Error Sintactico: "+s.value.toString()+" Linea: "+(s.right+1)+";");
    }
:};
	

	
//DECLARACION DE TERMINALES
	 terminal  String PROGRAM,IDENT ,POINT_SEMICOLON,BEGIN,POINT,END,
	 DOUBLEPOINTEQUAL,NUMERIC_REAL_CONST,OPEN_PARENTESIS,CLOSE_PARENTESIS,
	 NUMERIC_INTEGER_CONST,STRING_CONST,MOD,MULTIPLICACION,PLUS,DIV,MINUS,SEMICOLON,CONST,
	 PROCEDURE,FUNCTION,DOUBLE_COLON,VAR,INTEGER,REAL,EQUAL;

	 
	 

//NO TERMINALES
	non terminal Programa BLQ,PRG;
	non terminal Sentencia SENT,ASIG,PROC_CALL,ID;
	non terminal ArrayList<Sentencia> SENTLIST;
	non terminal ArrayList<SubSentencia> EXP ;
	non terminal ArrayList<ArrayList<SubSentencia>> EXPLIST;
	non terminal SubSentencia OP,FACTOR;
	non terminal Funcion DCL,DEFCTE,DEFVAR,DEFPROC,DEFFUN;
	non terminal ArrayList<Funcion> DCLLIST,CTELIST,DEFVARLIST;
	non terminal SubFuncion	FORMAL_PARAMLIST,TBAS ;
	non terminal ArrayList<SubFuncion> FORMAL_PARAM;
	non terminal ArrayList<String> VARLIST;
	non terminal Simbolo SUBPARAMLIST,SIMPVALUE,OPARIT;
	
	

	
/*ORDENAMIENTO (rompe ambiedad de jerarquia)*/
precedence left STRING_CONST ,NUMERIC_REAL_CONST,NUMERIC_INTEGER_CONST;
precedence left MOD,MULTIPLICACION,PLUS,DIV,MINUS;
	
start with PRG;	
//GRAMATICA
//ASIGNACIONES
PRG ::= PROGRAM:p IDENT:id POINT_SEMICOLON:ps BLQ:b  POINT:pt{:
	Programa programa = new Programa();
	programa.programa = "program";
	programa.identificador = id;
	programa.puntocoma = ";";
	pgrArray.add(programa);
	RESULT =programa;:} 
;

BLQ ::=DCLLIST:dc BEGIN:b SENTLIST:s END:e{:
	Programa bloque = new Programa();
    bloque.empieza=b;
	bloque.fin=e;
    blqArray.add(bloque);
	RESULT =bloque; :} 
	;
	
/// PARTE1
/////////////////////// parte 1

DCLLIST ::=  DCLLIST:dcl DCL:dc{: 
		RESULT=dclArray;:} |;
	
	

DCL ::=DEFCTE:d {: 
			RESULT =d; :}  
		|DEFVAR:dv {:
			RESULT = dv; :} 
		| DEFPROC:dp{:
			RESULT =dp; :} 
		| DEFFUN:df{: 
			RESULT =df; :} 
	;	
	
	
///////////////////////////////////////////////////////////// VARIABLES	
		DEFVAR ::= VAR:v DEFVARLIST POINT_SEMICOLON:p  {: 
			Funcion defvar = new Funcion();
			defvar.variable="var";
			dclArray.add(defvar);
			RESULT =defvar;  :} 
	;



    DEFVARLIST ::= VARLIST:v DOUBLE_COLON:d TBAS:t  {:
			Funcion defvarlist = new Funcion();
			//defvarlist.varLista.add(prueba);
			defvarlist.dosPuntos = d;
			defvarlist.tbas=t.tbas;
			dclArray.add(defvarlist);
			RESULT = dclArray;   :}	
	| DEFVARLIST:dl POINT_SEMICOLON:p VARLIST:v DOUBLE_COLON:d TBAS:t  {:
			Funcion defvarlist = new Funcion();
			//defvarlist.varLista.add(prueba);
			defvarlist.dosPuntos = d;
			defvarlist.tbas=t.tbas;
			dclArray.add(defvarlist);  
			dclArray.addAll(dl);
			RESULT = dclArray; :} 
			;

	VARLIST ::= IDENT:i  {: 
			SubFuncion subfuncion = new SubFuncion();
			subfuncion.identificador="ww";
			prueba.add(i);
			RESULT =prueba; :}
	| IDENT:i  SEMICOLON:s VARLIST:v  {:
			SubFuncion subfuncion = new SubFuncion();
			subfuncion.identificador = "ee";
			prueba.add(i);
			prueba.addAll(v);

       		RESULT =prueba;  :}
	;
	
	

	TBAS ::= INTEGER {: 
			SubFuncion tbas= new SubFuncion();
			tbas.entero ="integer";
			subdclArray.add(tbas);
			RESULT =tbas; :}
	| REAL {: 
			SubFuncion tbas= new SubFuncion();
			tbas.real ="real";
			subdclArray.add(tbas);	
			RESULT =tbas;  :}
	;
	
	
	
	
///////////////////////////////////////////////////////////// CONSTANTES	
	
	
	DEFCTE ::=CONST:cons CTELIST:ct {: 
			Funcion defcte=new Funcion();
			RESULT = defcte; :} 
	;
	
		
	
	CTELIST ::= IDENT:i EQUAL:e SIMPVALUE:s POINT_SEMICOLON:ps{: 
				Funcion ctelist = new Funcion();
				ctelist.identificador = i;
				ctelist.igual = e;
				ctelist.simpvalue = s.simpvalue;
				ctelist.puntocoma = ps;
				dclArray.add(ctelist);
				RESULT = dclArray;  :} 
	|CTELIST:cl IDENT:i EQUAL:e SIMPVALUE:s  POINT_SEMICOLON:ps{: 
				Funcion ctelist = new Funcion();
				ctelist.identificador = i;
				ctelist.igual = e;
				ctelist.simpvalue = s.simpvalue;
				ctelist.puntocoma = ps;
				dclArray.add(ctelist);
				dclArray.addAll(cl);
				RESULT = dclArray; :} 
	;
	

///////////////////////////////////////////////////////////// PROCEDIMIENTOS	
	

	DEFPROC ::= PROCEDURE:p IDENT:i FORMAL_PARAMLIST:fo POINT_SEMICOLON:ps1 BLQ:b POINT_SEMICOLON:ps2{:
  			Funcion defproc = new Funcion();
			defproc.procedimiento = p;
			defproc.identificador = i;
			dclArray.add(defproc);
			RESULT = defproc;:} 
	;
	
	

	FORMAL_PARAMLIST ::= OPEN_PARENTESIS:o FORMAL_PARAM:f CLOSE_PARENTESIS:c {:
			SubFuncion formalParam= new SubFuncion();
			RESULT = formalParam;:}|
	;
	


	FORMAL_PARAM ::= VARLIST:v DOUBLE_COLON:d  TBAS:t {:
			SubFuncion formalParam= new SubFuncion();
			subdclArray.add(formalParam);
		 	RESULT =subdclArray;  :} 
	| VARLIST:v DOUBLE_COLON:d TBAS:t  POINT_SEMICOLON:ps FORMAL_PARAM:fp {: 
			SubFuncion formalParam= new SubFuncion();
			subdclArray.add(formalParam);
			subdclArray.addAll(fp);
			RESULT =subdclArray;  :} ;
	
	
	
///////////////////////////////////////////////////////////// FUNCIONES

	DEFFUN ::= FUNCTION:f IDENT:i FORMAL_PARAMLIST:fo DOUBLE_COLON:d TBAS:t POINT_SEMICOLON:p1 BLQ:b POINT_SEMICOLON:p2{: 
	  		Funcion funcion = new Funcion();
			RESULT =funcion; :} 
	;

	
// PARTE 2 PRINICPAL	

	SENTLIST ::= SENT:s {: 
	Programa p=new Programa();
	sentArray.add(s);
	RESULT = sentArray;
	 :}
	|SENTLIST:sl SENT:s {: 
	sentArray.add(s);
	sentArray.addAll(sl);
	RESULT = sentArray;
 :} 
 ;


SENT ::= ASIG:a  POINT_SEMICOLON:ps{: 
		Sentencia sentenc=new Sentencia();
		sentenc.puntocoma=ps;
		sentArray.add(sentenc);
		RESULT =sentenc; :}
|PROC_CALL:pc POINT_SEMICOLON:ps{: 
		Sentencia sentenc=new Sentencia();
		sentenc.dosPuntos=ps;
		sentArray.add(sentenc);
		RESULT =sentenc;  :}
	;


ASIG ::= ID:id DOUBLEPOINTEQUAL:de EXP:e  {: 
			Sentencia sentencia= new Sentencia();
			RESULT =sentencia; :};

ID ::= IDENT:i{: 
			Sentencia sent= new Sentencia();
			sent.identificador =i;
			sentArray.add(sent);
			RESULT = sent;  :};			


	EXP ::= EXP:e1 OP:o EXP:e2  {: 
			SubSentencia subsentencia = new SubSentencia();
			subsentArray.addAll(e1);
			subsentArray.add(o);
			subsentArray.addAll(e2);
			RESULT = subsentArray;
:}
	| FACTOR:f  {: 
			SubSentencia subsentencia  = new SubSentencia();
			subsentArray.add(f);
			RESULT =subsentArray; :}
	;
	
	OP ::= OPARIT:o  {: 
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.op=o.op;
			RESULT =subsentencia;  :}
	;


	OPARIT ::= PLUS:p {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mas =p;
			simbolo.esMas=true;
			RESULT =simbolo; 
	:}
	| MINUS:mi  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.menos=mi;
			simbolo.esMenos=true;
			RESULT =simbolo;  
	:}
	| MULTIPLICACION:mu {:  
			Simbolo simbolo= new Simbolo();
			simbolo.multiplica =mu;
			simbolo.esMultiplica=true;
			RESULT=simbolo;
	:}
	| DIV:d  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.divide =d;
			simbolo.esDivide=true;
			RESULT =simbolo;
	 :}
	| MOD:m {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mod =m;
			simbolo.esMod=true;
			RESULT = simbolo;
	:}
	;
	
	
 
	FACTOR ::= SIMPVALUE:s  {: 
		SubSentencia subsentencia = new SubSentencia();
		RESULT =subsentencia;  :}
	| OPEN_PARENTESIS:o EXP:e CLOSE_PARENTESIS:c {:
			SubSentencia subsentencia = new SubSentencia();
			
			RESULT =subsentencia; :}
	| IDENT:i  SUBPARAMLIST:s  {: 
			SubSentencia subsentencia = new SubSentencia();
			RESULT =subsentencia; 
	:}
	;

SIMPVALUE ::= NUMERIC_INTEGER_CONST:ni {:
			Simbolo integer= new Simbolo();
			integer.numericoEnteroConstante =ni;
			integer.esNumericoEnteroConstante=true;			
			RESULT =integer; :}
	 		
			| NUMERIC_REAL_CONST:nr {: 
			Simbolo real= new Simbolo();
			real.numericoRealConstante =nr;
			real.esNumericoRealConstante=true;	
			RESULT =real; :}
			
			| STRING_CONST:sc  {: 
			Simbolo constante= new Simbolo();
			constante.textoconstante =sc;
			constante.esTextoconstante=true;	
			RESULT =constante; :}
	;


PROC_CALL ::= IDENT:i SUBPARAMLIST:s {:
			Sentencia sentencia= new Sentencia();
			sentencia.identificador=i;
 			sentArray.add(sentencia);
			RESULT =sentencia; :}
	;	
	
SUBPARAMLIST ::=  OPEN_PARENTESIS:o EXPLIST:e CLOSE_PARENTESIS:c {: 
			Sentencia sentencia= new Sentencia();
			sentencia.abreParenteis =o;
			sentencia.cierraParentesis =c;
			sentArray.add(sentencia);
			RESULT =sentencia;
		:}|
		;

// ARRAY
EXPLIST ::= EXP:e  {: 
			expListArray.add(e);
			RESULT = expListArray;  :}
	| EXP:e SEMICOLON:s EXPLIST:ex  {: 
			expListArray.add(e);
			expListArray.addAll(ex);
			RESULT =expListArray;  :}
	;
	 



