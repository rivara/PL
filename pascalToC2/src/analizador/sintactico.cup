	package analizador;
//LIBRERIAS
	import java_cup.runtime.*;
	import java_cup.runtime.Symbol;
	import java.io.FileOutputStream;
	import java.io.IOException;
//CONTROL DE ERRORESZ 
	parser code {:

public void syntax_error (Symbol s){
	System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	System.err.println("Error recuperado");
}

public void unrecovered_syntax_error(Symbol s){
	System.err.println("Error de sintaxis no recuperable");
}
:};
	
	
//DECLARACION DE TERMINALES
// ver porque hector tiene algunos terminales definidos como String
	terminal String PROGRAM,FUNCTION,PROCEDURE, BEGIN,END,VAR,OPEN_PARENTESIS,CLOSE_PARENTESIS,POINT_SEMICOLON,
	 SEMICOLON,EQUAL,DOUBLE_COLON,CONST,IDENTIFIER,NUMERIC_REAL_CONST,
	 NUMERIC_INTEGER_CONST,STRING_CONST,VACIO,MOD,MULTIPLICACION,PLUS,DIV,MINUS,END_COMENT;
	 
	 //MOD , MULTIPLICACION , PLUS ,DIV,MINUS,REAL
// terminal DOUBLE_COLON_EQUAL;
//terminal RETURN; 
//terminal VOID;
//terminal INT;
//terminal FLOAT;
//terminal IF;
//terminal THEN;
//terminal ELSE;	
//terminal WHILE;
//terminal DO;
//terminal REPEAT;
//terminal UNTIL;
//terminal FOR;
//terminal DOWNTO;
//terminal OR;
//terminal AND;
//terminal NOT;
//terminal GRETTER;
//terminal LESS;
//terminal GRETTER_EQUAL;
//terminal LESS_EQUAL;
//terminal PLUS_EQUAL;
//terminal MINUS_EQUAL;
//terminal MULTIPLICACION_EQUAL;
//terminal DIV_EQUAL;
	
//terminal END_COMENT;
//terminal JUMP;
	
//NO TERMINALES
// Top de la gramatica 
// metodo list de arraylist 
// metodo recorrer y expulsarlo en el fichero  
	non terminal Programa PRG,BLQ;
	non terminal Sentencia SENTLIST,SENT,ASIG,EXP,FACTOR,SUBPARAMLIST,EXPLIST,PROC_CALL;
	non terminal Funcion DCLLIST,DCL,DEFCTE,CTELIST, DEFVAR,DEFVARLIST,VARLIST,DEFPROC,DEFFUN,FORMAL_PARAMLIST,FORMAL_PARAM;
	non terminal Simbolo  TBAS,OP,OPARIT,ID,SIMPVALUE;
	

	
	

	
	
/*ORDENAMIENTO (rompe ambigüedad de jerarquia)*/
	precedence left OPEN_PARENTESIS,CLOSE_PARENTESIS, PLUS, MINUS,MULTIPLICACION,DIV,MOD;
	
//GRAMATICA
	
	
PRG ::= PROGRAM IDENTIFIER:id  BLQ:b  {: 
	//eporta todos los arraylist a un fichero de texto llamado Programa.c
	//main.exportaFichero(p)
	Programa bloque = new Programa();
	bloque.empieza = "begin";
	bloque.esEmpieza = true;
	bloque.fin = "end";
	bloque.esFin = true;
	RESULT = bloque;:} 
	;

	BLQ ::= DCLLIST:dc BEGIN SENTLIST:sl END{:
	Programa bloque = new Programa();
	bloque.dclLista.add(dc);	
	bloque.empieza ="begin";
	bloque.esEmpieza = true;	
	bloque.sentLista.add(sl);
	bloque.fin ="end";
	bloque.esFin = true;
	RESULT =bloque; :} 
	;
	
	
	
	
	DCLLIST ::=  DCLLIST:dcl DCL:dc {: 
	Programa p=new Programa();
	Funcion function = new Funcion();
	function.dclLista.add(dc);
	p.dclLista.addAll(dcl.dclLista);
	//p.declaraciones.add(sentencia);
	//p.declaraciones.addAll(listaDef.declaraciones);
	RESULT = function;
	:} |VACIO|;
	
	SENTLIST ::= SENT:s {: 
//Acumulacion de 1 elemento solo en un arraylist
	Programa sentlist;
	sentlist.add(s);
	RESULT =sentlist; :} 
	
	|SENTLIST:sl SENT:s {: 
//Acumulacion de todos los dcl de la llamada recursiva
	Sentencia sentencia= new Sentencia();
	sentencia=sl;
	sentencia.add(s);
	RESULT=sentLista;
 :} 
	;
	DCL ::=DEFCTE:d {: 
		   	Funcion defcte=new Funcion();;
			defcte=d;
			RESULT =defcte; :}  
		|DEFVAR:dv {:
	 		Funcion defvar=new Funcion();;
			defvar=dv;
			RESULT = defvar; :} 
		| DEFPROC:dp{: 
			Funcion defproc=new Funcion();;
			defproc=dp;
			RESULT =defproc; :} 
		| DEFFUN:df{: 
			Funcion defvar=new Funcion();;
			deffun=df;
			RESULT =deffun; :} 
	;	
	
	DEFCTE ::=CONST:cons CTELIST:ct {: 
			Funcion defcte=new Funcion();;
			defcte.constante =cons;
			defcte.esConstante = true;	
			Lista cteLista;
			defcte.cteLista=ct.cteLista;
			RESULT =defcte;  :} 
	;
	


	CTELIST ::= IDENTIFIER:i EQUAL:e SIMPVALUE:s POINT_SEMICOLON:p{: 
			//ctelist
			Funcion ctelist=new Funcion();;
			ctelist.identificador =i;
			ctelist.esIdenoicador=true;
			ctelist.igual =e;
			ctelist.esIgual=true;			
			ctelist.puntocoma =p;
			ctelist.esPuntocoma=true;
			RESULT =ctelist; :} 


	|CTELIST:cl IDENTIFIER:i EQUAL:e SIMPVALUE:s  POINT_SEMICOLON:p{: 
				Programa p = new Programa();
				Funcion ctelist = new Funcion();
				ctelist.identificador = i;
				ctelist.esIdenoicador = true;
				ctelist.igual = e;
				ctelist.esIgual = true;
				ctelist.puntocoma = p;
				ctelist.esPuntocoma = true;
				ctelist.all();
				//añadair 
				p.ctelist.addAll(c1);
			//p.declaraciones.add(sentencia);
	//p.declaraciones.addAll(listaDef.declaraciones);
			
				RESULT =cl; :} 
	;
		//non terminal Declaraciones CTELIST,SIMPVALUE,DEFVARLIST,VARLIST,FORMAL_PARAMLIST,FORMAL_PARAM;
	SIMPVALUE ::= NUMERIC_INTEGER_CONST:ni {:
			Simbolo integer= new Simbolo();
			integer.numericoEnteroConstante =ni;
			integer.esNumericoEnteroConstante=true;			
			RESULT =integer; :}
	 		
			| NUMERIC_REAL_CONST:nr {: 
			Simbolo real= new Simbolo();
			real.numericoRealConstante =e;
			real.esNumericoRealConstante=true;	
			RESULT =real; :}
			
			| STRING_CONST:sc  {: 
			Simbolo constante= new Simbolo();
			constante.textoconstante =e;
			constante.esTextoconstante=true;	
			RESULT =constante; :}
	;
	

	DEFVAR ::= VAR:v DEFVARLIST:d POINT_SEMICOLON:p  {: 
			Simbolo var= new Simbolo();
			var.variable =v;
			var.esVariable=true;			
			Simbolo ps= new Simbolo();
			ps.puntocoma =p;
			ps.esPuntocoma=true;
//Agrupo todo en definicion		
			Definicion definicion= new Definicion();
			definicion.simbolo.add(v);
			definicion.declaraciones.defvarLista= d.defvarLista;
			definicion.simbolo.add(p);
			RESULT =definicion;  :} 
	;
	
	DEFVARLIST ::= VARLIST:v DOUBLE_COLON:d TBAS:t  {:
			Simbolo dbc= new Simbolo();
			dbc.dosPuntos =d;
			dbc.dosPuntos=true;		
			Definicion definicion= new Definicion();
			definicion.varLista=v.varLista;
			definicion.add(d);
			definicion.tbas=t.tbas;
			RESULT = definicion; :} 
	| DEFVARLIST:d POINT_SEMICOLON:p VARLIST:v DOUBLE_COLON:d TBAS:t  {:
//RVR PROBLEMA CONCATENAR CON LO ANTERIOR		
			Simbolo ps= new Simbolo();
			ps.puntocoma =p;
			ps.esPuntocoma=true;		
			Simbolo dbc= new Simbolo();
			dbc.dosPuntos =d;
			dbc.esDosPuntos=true;	
			Definicion definicion= new Definicion();
			declaraciones.listaDefvarlista.addAll(cl);
			definicion.varLista=v.varLista;
			definicion.add(d);
			definicion.tbas=t.tbas;
 			RESULT =definicion;:} 
	;
	
	
	
	VARLIST ::= IDENTIFIER:i  {: 
			Simbolo id= new Simbolo();
			id.identificador =i;
			id.esIdentificador=true;
			Definicion definicion= new Definicion();
			definicion.add(id);		
       		RESULT =id; :}
	| IDENTIFIER:i  SEMICOLON:s VARLIST:v  {: 
			Simbolo id= new Simbolo();	
			id.identificador =i;
			id.esIdentificador=true;	
			Simbolo sc= new Simbolo();	
			sc.coma =s;
			sc.esComa=true;
			Definicion definicion= new Definicion();
			definicion.add(id);	
			definicion.add(sc);	
			definicion.varLista=v.varLista;
       		RESULT =definicion; :}
	;
	

	DEFPROC ::= PROCEDURE:p IDENTIFIER:i FORMAL_PARAMLIST:fo POINT_SEMICOLON:ps1 BLQ:b POINT_SEMICOLON:ps2{:
  			Simbolo pro= new Simbolo();	
			pro.procedimiento =p;
			pro.esProcedimiento=true;
			Simbolo id= new Simbolo();	
			id.identificador =i;
			id.esIdentificador=true;	
			Simbolo pos1= new Simbolo();
			pos1.puntocoma =ps1;
			pos1.esPuntocoma=true;
			Simbolo pos2= new Simbolo();
			pos2.puntocoma =ps2;
			pos2.esPuntocoma=true;
/////////////////////////////////			
			Definicion definicion= new Definicion();
			definicion.add(pro);	
			definicion.add(id);	
			definicion.formal_paramLista=fo.formal_paramLista;
			definicion.add(pos1);	
			definicion.bloque=b.bloque;
			definicion.add(pos2);
			RESULT =definicion;:} 
	;
	
	DEFFUN ::= FUNCTION:f IDENTIFIER:i FORMAL_PARAMLIST:fo DOUBLE_COLON:d TBAS:t POINT_SEMICOLON:p1 BLQ:b POINT_SEMICOLON:p2{: 
	  		Simbolo fun= new Simbolo();	
			fun.funcion =f;
			fun.esFuncion=true;
			Simbolo id= new Simbolo();	
			id.identificador =i;
			id.esIdentificador=true;
			Simbolo dbc= new Simbolo();
			dbc.dosPuntos =d;
			dbc.esDosPuntos=true;	
			Simbolo pos1= new Simbolo();
			pos1.puntocoma =p1;
			pos1.esPuntocoma=true;
			Simbolo pos2= new Simbolo();
			pos2.puntocoma =p2;
			pos2.esPuntocoma=true;
//////////////////////////////
			Definicion definicion= new Definicion();
			definicion.add(fun);	
			definicion.add(id);	
			definicion.formal_paramLista=fo.formal_paramLista;
			definicion.tbas=t.tbas;
			definicion.bloque=b.bloque;
			RESULT =definicion; :} 
	;
	
	

	FORMAL_PARAMLIST ::= OPEN_PARENTESIS:o FORMAL_PARAM:f CLOSE_PARENTESIS:c {: 
			Simbolo op= new Simbolo();
			op.abreParenteis =o;
			op.esAbreParenteis=true;	
			
			Simbolo cp= new Simbolo();
			cp.cierraParentesis =c;
			cp.esCierraParentesis=true;	

			Declaraciones declaraciones= new Declaraciones();
			declaraciones.add(cp);	
			declaraciones.parametrosFormales=f.parametrosFormales;
			declaraciones.add(cp);	
			RESULT =declaraciones;:} |VACIO|
	;
	
	
	
	FORMAL_PARAM ::= VARLIST:v DOUBLE_COLON:d  TBAS:t {:
			Simbolo dbc= new Simbolo();
			dbc.dosPuntos =d;
			dbc.esDosPuntos=true;
			Definicion definicion= new Definicion();
			definicion.varLista=v.varLista;
			definicion.add(dbc);	
			definicion.tbas=t.tbas;
	 		RESULT =definicion; :} 
	| VARLIST:v DOUBLE_COLON:d TBAS:t  POINT_SEMICOLON:ps FORMAL_PARAM:f {: 
			Simbolo dbc= new Simbolo();
			dbc.dosPuntos =d;
			dbc.esDosPuntos=true;	
			Simbolo pos= new Simbolo();
			pos.puntocoma =ps;
			pos.esPuntocoma=true;

			Definicion definicion= new Definicion();
			definicion.varLista=v.varLista;	
			definicion.add(dbc);	
			definicion.tbas=t.tbas;
			definicion.add(ps);	
			definicion.parametrosFormales=f.parametrosFormales;
			RESULT =definicion;  :} 
	;
	
	TBAS ::= NUMERIC_INTEGER_CONST:n {: 
			Simbolo simbolo= new Simbolo();
			simbolo.numericoEnteroConstante =ni;
			simbolo.esNumericoEnteroConstante=true;	
			RESULT =simbolo; :}
	| NUMERIC_REAL_CONST:r {: 
			Simbolo simbolo= new Simbolo();
			simbolo.real =ni;
			simbolo.esReal=true;	
			RESULT =simbolo;  :}
	;
	
	
	////////////////////EXP
	SENT ::= ASIG:a POINT_SEMICOLON:ps {: 
			Simbolo pos= new Simbolo();
			pos.puntocoma =ps;
			pos.esPuntocoma=true;
			Expresion expresion= new Expresion();
			expresion.asig=a.asig;
			expresion.add(pos);
			RESULT =expresion; :}
	| PROC_CALL:p POINT_SEMICOLON:ps {: 
			Simbolo pos= new Simbolo();
			pos.puntocoma =ps;
			pos.esPuntocoma=true;
			Expresion expresion= new Expresion();
			expresion.procCall=p.procCall;
			expresion.add(pos);
			RESULT =expresion;  :}
	;
	
	

	ASIG ::= ID:i POINT_SEMICOLON:ps EXP:e {: 
			Simbolo pos= new Simbolo();
			pos.puntocoma =ps;
			pos.esPuntocoma=true;
			Expresion expresion= new Expresion();
			expresion.id=i.id;
			expresion.add(pos);
			expresion.exp=e.exp;
			RESULT =expresion; :}
	;
	
	ID ::= IDENTIFIER:i {: 
			Simbolo simbolo= new Simbolo();
			simbolo.identificador =i;
			simbolo.esIdentificador=true;
			RESULT = simbolo; :}
	;
	
	EXP ::= EXP:e1 OP:o EXP:e2  {: 
			Expresion expresion= new Expresion();
			expresion.exp=e1;
			expresion.op=o;
			expresion.exp=e2;
			RESULT=expresion;  :}
	| FACTOR:f  {: 
			Expresion expresion= new Expresion();
			expresion.factor=f.factor;
			RESULT =expresion; :}
	;
	
	OP ::= OPARIT:o  {: 
			Expresion expresion= new Expresion();
			expresion.op=o;
			RESULT =expresion;  :}
	;
	
	OPARIT ::= PLUS:p {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mas =p;
			simbolo.esMas=true;
			RESULT =simbolo; 
	:}
	| MINUS:mi  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.menos mi;
			simbolo.esMenos=true;
			RESULT =simbolo;  
	:}
	| MULTIPLICACION:mu {:  
			Simbolo simbolo= new Simbolo();
			simbolo.multiplica =mu;
			simbolo.esMultiplica=true;
			RESULT=simbolo;
	:}
	| DIV:d  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.divide =d;
			simbolo.esDivide=true;
			RESULT =simbolo;
	 :}
	| MOD:m {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mod =m;
			simbolo.esMod=true;
			RESULT = simbolo;
	:}
	;
	
	
	
	FACTOR ::= SIMPVALUE:s  {: 
		Expresion expresion= new Expresion();
		expresion.valorsimple=s.valorsimple;
		RESULT =expresion;  :}
	| OPEN_PARENTESIS:o EXP:e CLOSE_PARENTESIS:c {:
			Simbolo op= new Simbolo();
			op.abreParenteis =o;
			op.esAbreParenteis=true;	
			Simbolo cp= new Simbolo();
			cp.cierraParentesis =c;
			cp.esCierraParentesis=true;	 
			Expresion expresion= new Expresion();
			expresion.add(op);
			expresion.exp=e.exp;
			expresion.add(cp);
			RESULT =expresion; :}
	| IDENTIFIER:i  SUBPARAMLIST:s  {: 
			Simbolo id= new Simbolo();
			simbolo.identificador =i;
			simbolo.esIdentificador=true;
			Expresion expresion= new Expresion();
			expresion.add(id);
			expresion.subparamLista=s.subparamLista;
			RESULT =expresion; 
	:}
	;
	
	SUBPARAMLIST ::=  OPEN_PARENTESIS:o EXPLIST:e CLOSE_PARENTESIS:c  {: 
			Simbolo op= new Simbolo();
			op.abreParenteis =o;
			op.esAbreParenteis=true;	
			Simbolo cp= new Simbolo();
			cp.cierraParentesis =c;
			cp.esCierraParentesis=true;	 
			Expresion expresion= new Expresion();
			expresion.add(op);
			expresion.expLista=e.expLista;
			expresion.add(cp);
			RESULT =expresion;
		:}
		;
	
	EXPLIST ::= EXP:e  {: 
			Expresion expresion= new Expresion();
			expresion.exp=e.exp;
			RESULT =expresion; :}
	| EXP:e SEMICOLON:s EXPLIST:ex  {: 
			Expresion expresion= new Expresion();
			expresion.expLista=e.expLista;
			RESULT =expresion;  :}
	;
	 
	PROC_CALL ::= IDENTIFIER:i SUBPARAMLIST:s {:
			Expresion expresion= new Expresion();
 			expresion.procCall=p.procCall;
			RESULT =expresion; :}
	;
	
	
	
