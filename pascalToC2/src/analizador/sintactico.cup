	package analizador;
//LIBRERIAS
	import java_cup.runtime.*;
	import java_cup.runtime.Symbol;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.util.ArrayList;

//CONTROL DE ERRORES 
parser code {:
 	public static ArrayList<String> pgr = new ArrayList<String>(); 
  	public static ArrayList<String> ErroresSintacticos=new ArrayList<String>();
	public int cont = 0;
	   
	

    /**Metodo al que se llama automÃ¡ticamente ante algÃºn error sintactico.*/
    public void syntax_error(Symbol s){
        System.out.println("Error en la LÃ­nea " + (s.right+1) +" Columna "+s.left+ ". Identificador "
        +s.value + " no reconocido." );
     ErroresSintacticos.add("Error Sintactico: "+s.value.toString()+" Linea: "+(s.right+1)+";");
    }



    /**Metodo al que se llama en el momento en que ya no es posible una recuperaciÃ³n de
    errores.*/
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.out.println("Error en la Linea " + (s.right+1)+ " Columna "+s.left+". Identificador " +
        s.value + " no reconocido.");
 ErroresSintacticos.add("Error Sintactico: "+s.value.toString()+" Linea: "+(s.right+1)+";");
    }




:};
	
	
//DECLARACION DE TERMINALES
	/*terminal String PROGRAM,FUNCTION,PROCEDURE, BEGIN,END,VAR,OPEN_PARENTESIS,CLOSE_PARENTESIS,POINT_SEMICOLON,
	 SEMICOLON,EQUAL,DOUBLE_COLON,CONST,IDENTIFIER,NUMERIC_REAL_CONST,POINT,
	 NUMERIC_INTEGER_CONST,STRING_CONST,VACIO,MOD,MULTIPLICACION,PLUS,DIV,MINUS;*/
	 
	 terminal  String PROGRAM,IDENT ,POINT_SEMICOLON;
	 /* _if, _else, _while, _do, _until, _for, 
	negacion, and, or, igualdad, menorIgual, mayorIgual, mayor, menor, 
	_define, suma, resta, Tvoid, Tint, Tfloat, _return, 
	constint, constlit, constfloat, 
	llaveAbierta, llaveCerrada, parentesisAbierto, parentesisCerrado, 
	coma, multiplicacion, division, modulo, asignacion, puntoYComa, ident;*/
	 
	 

//NO TERMINALES
	non terminal Programa BLQ,PRG;
	/*non terminal Sentencia SENTLIST,SENT,ASIG,SUBPARAMLIST,PROC_CALL;
	non terminal Funcion DCLLIST,DCL,DEFCTE,DEFVAR,DEFPROC,DEFFUN,FORMAL_PARAMLIST;
	non terminal SubSentencia FACTOR,EXPLIST;
	non terminal SubFuncion CTELIST,DEFVARLIST,VARLIST,FORMAL_PARAM;
	non terminal Simbolo  OP,TBAS,OPARIT,ID,SIMPVALUE,EXP;*/


	
	

	
	
/*ORDENAMIENTO (rompe ambigüedad de jerarquia)*/
	//precedence left OPEN_PARENTESIS,CLOSE_PARENTESIS, PLUS, MINUS,MULTIPLICACION,DIV,MOD;
	
//GRAMATICA
//ASIGNACIONES
// quitar blq y añadir ""a ver si lo reconoce asi	
start with PRG;

PRG ::= PROGRAM:p IDENT:id  POINT_SEMICOLON:ps{:
	Programa programa = new Programa();
	programa.programa = "program";
	programa.identificador = id;
	programa.puntocoma = ";";
	pgr.add(ps);
	pgr.add(id);
	pgr.add(p);
	RESULT =programa;:}  //procesarFor(p.toString());:} 
	;
/*
BLQ ::= DCLLIST:dc BEGIN:b SENTLIST:sl END:e{:
	Programa bloque = new Programa();
	bloque.dclLista=dc.dclLista;
	bloque.empieza =b;
	bloque.esEmpieza = true;
	bloque.sentLista=sl.sentLista;
	bloque.fin =e;
	bloque.esFin = true;
	RESULT =bloque; :} 
	;
	
	
	DCLLIST ::=  DCLLIST:dcl DCL:dc {: 
	Funcion function = new Funcion();
	function.dclLista.add(dc);
	function.dclLista.addAll(dcl.dclLista);
	RESULT = function;
	:} |VACIO|;
	
	SENTLIST ::= SENT:s {: 
	Programa p=new Programa();
	Sentencia sentencia = new Sentencia();
	p.sentLista.add(s);
	RESULT = sentencia;
	 :}
	|SENTLIST:sl SENT:s {: 
	Programa p=new Programa();
	Sentencia sentencia = new Sentencia();
	p.sentLista.add(s);
	p.sentLista.addAll(sl.sentLista);
	RESULT = sentencia;
 :} 
	;
	DCL ::=DEFCTE:d {: 
		   	Funcion defcte=new Funcion();;
			defcte=d;
			RESULT =defcte; :}  
		|DEFVAR:dv {:
	 		Funcion defvar=new Funcion();;
			defvar=dv;
			RESULT = defvar; :} 
		| DEFPROC:dp{: 
			Funcion defproc=new Funcion();;
			defproc=dp;
			RESULT =defproc; :} 
		| DEFFUN:df{: 
			Funcion defvar=new Funcion();;
			defvar=df;
			RESULT =defvar; :} 
	;	
	
	
	
	
	DEFCTE ::=CONST:cons CTELIST:ct {: 
			Funcion defcte=new Funcion();
			SubFuncion subfuncion =new SubFuncion();
			defcte.constante = cons;
			defcte.esConstante = true;
			subfuncion.cteLista=ct.cteLista;
			RESULT = defcte; :} 
	;
	

	CTELIST ::= IDENTIFIER:i EQUAL:e SIMPVALUE:s POINT_SEMICOLON:ps{: 
				Funcion funcion = new Funcion();
				SubFuncion subfuncion = new SubFuncion();
				Simbolo simbolo= new Simbolo();
				simbolo.identificador = i;
				simbolo.esIdenoicador = true;
				simbolo.igual = e;
				simbolo.esIgual = true;
				simbolo.simpvalue = s.simpvalue;
				simbolo.puntocoma = ps;
				simbolo.esPuntocoma = true;
				subfuncion.cteLista.add(simbolo);
				RESULT = subfuncion;  :} 
	|CTELIST:cl IDENTIFIER:i EQUAL:e SIMPVALUE:s  POINT_SEMICOLON:ps{: 
				Funcion funcion = new Funcion();
				SubFuncion subfuncion = new SubFuncion();
				Simbolo simbolo= new Simbolo();
				simbolo.identificador = i;
				simbolo.esIdenoicador = true;
				simbolo.igual = e;
				simbolo.esIgual = true;
				simbolo.simpvalue = s.simpvalue;
				simbolo.puntocoma = ps;
				simbolo.esPuntocoma = true;
				subfuncion.cteLista.add(simbolo);
				subfuncion.cteLista.addAll(cl.cteLista);
				RESULT = subfuncion; :} 
	;
	
	
	
	
	SIMPVALUE ::= NUMERIC_INTEGER_CONST:ni {:
			Simbolo integer= new Simbolo();
			integer.numericoEnteroConstante =ni;
			integer.esNumericoEnteroConstante=true;			
			RESULT =integer; :}
	 		
			| NUMERIC_REAL_CONST:nr {: 
			Simbolo real= new Simbolo();
			real.numericoRealConstante =nr;
			real.esNumericoRealConstante=true;	
			RESULT =real; :}
			
			| STRING_CONST:sc  {: 
			Simbolo constante= new Simbolo();
			constante.textoconstante =sc;
			constante.esTextoconstante=true;	
			RESULT =constante; :}
	;
	
//ASIGNA
	DEFVAR ::= VAR:v DEFVARLIST:d POINT_SEMICOLON:p  {: 
			Funcion funcion = new Funcion();
			Simbolo simbolo = new Simbolo();
			simbolo.variable = v;
			simbolo.esVariable = true;
			simbolo.devarlista = d.devarlista;
			simbolo.puntocoma = p;
			simbolo.esPuntocoma = true;
			RESULT =funcion;  :} 
	;
	
	
	
////////////////// AGREGA	
	DEFVARLIST ::= VARLIST:v DOUBLE_COLON:d TBAS:t  {:
			SubFuncion subfuncion = new SubFuncion();
			Simbolo simbolo = new Simbolo();
			simbolo.varLista=v.varLista;
			simbolo.dosPuntos = d;
			simbolo.esDosPuntos =true;
			simbolo.tbas=t.tbas;
			subfuncion.defvarLista.add(simbolo);
			RESULT = subfuncion;  :}	
	| DEFVARLIST:dl POINT_SEMICOLON:p VARLIST:v DOUBLE_COLON:d TBAS:t  {:
			SubFuncion subfuncion = new SubFuncion();
			Simbolo simbolo = new Simbolo();
			simbolo.puntocoma = p;
			simbolo.esPuntocoma = true;
			simbolo.varLista=v.varLista;
			simbolo.dosPuntos = d;
			simbolo.esDosPuntos =true;
			subfuncion.defvarLista.add(simbolo);
			subfuncion.defvarLista.addAll(dl.defvarLista);
			subfuncion.cteLista.add(subfuncion);
			subfuncion.defvarLista.addAll(dl.defvarLista);
			RESULT = subfuncion; :} 
			;


////////////////// AGREGA
	VARLIST ::= IDENTIFIER:i  {: 
			SubFuncion subfuncion = new SubFuncion();
			Simbolo simbolo= new Simbolo();	
			simbolo.identificador =i;
			simbolo.esIdentificador=true;
			subfuncion.varLista.add(simbolo);		
       		RESULT =subfuncion; :}
	| IDENTIFIER:i  SEMICOLON:s VARLIST:v  {:
			SubFuncion subfuncion = new SubFuncion();
			Simbolo simbolo = new Simbolo();
			simbolo.identificador = i;
			simbolo.esIdentificador = true;
			simbolo.coma = s;
			simbolo.esComa = true;
			subfuncion.varLista.add(simbolo);
			subfuncion.varLista.addAll(v.varLista);
       		RESULT =subfuncion; :}
	;
	
////////////////// ASIGNA
	DEFPROC ::= PROCEDURE:p IDENTIFIER:i FORMAL_PARAMLIST:fo POINT_SEMICOLON:ps1 BLQ:b POINT_SEMICOLON:ps2{:
  			Funcion funcion = new Funcion();
			funcion.procedimiento = p;
			funcion.esProcedimiento = true;
			funcion.identificador = i;
			funcion.esIdentificador = true;
			funcion.formal_paramLista = fo.formal_paramLista;
			funcion.puntocoma = ps1;
			funcion.esPuntocoma = true;
			Programa bloque = new Programa();
			bloque = b;
			funcion.puntocoma = ps2;
			funcion.esPuntocoma = true;
			RESULT = funcion;:} 
	;
	
////////////////// ASIGNA
	DEFFUN ::= FUNCTION:f IDENTIFIER:i FORMAL_PARAMLIST:fo DOUBLE_COLON:d TBAS:t POINT_SEMICOLON:p1 BLQ:b POINT_SEMICOLON:p2{: 
	  		Funcion funcion = new Funcion();
			funcion.funcion = f;
			funcion.esFuncion = true;
			funcion.identificador = i;
			funcion.esIdentificador = true;
			funcion.formal_paramLista = fo.formal_paramLista;
			funcion.dosPuntos = d;
			funcion.esDosPuntos = true;
			funcion.tbas = t.tbas;
			funcion.puntocoma = p1;
			funcion.esPuntocoma = true;
			Programa bloque = new Programa();
			bloque = b;
			funcion.puntocoma = p2;
			funcion.esPuntocoma = true;
			RESULT =funcion; :} 
	;
	
	
////////////////// ASIGNA
	FORMAL_PARAMLIST ::= OPEN_PARENTESIS:o FORMAL_PARAM:f CLOSE_PARENTESIS:c {:
			Funcion funcion = new Funcion(); 
			funcion.abreParenteis =o;
			funcion.esAbreParenteis=true;	
			funcion.cierraParentesis =c;
			funcion.esCierraParentesis=true;	
			SubFuncion subfuncion= new SubFuncion();
			subfuncion.formal_param=f.formal_param;
			funcion.cierraParentesis =o;
			funcion.esCierraParentesis=true;:} |VACIO|
	;
	

/////////////////AGREGA hay bucle	
	FORMAL_PARAM ::= VARLIST:v DOUBLE_COLON:d  TBAS:t {:
			SubFuncion subfuncion= new SubFuncion();
			Simbolo simbolo= new Simbolo();
			simbolo.varLista=v.varLista;
			simbolo.dosPuntos =d;
			simbolo.esDosPuntos=true;
			simbolo.tbas=t.tbas;
			subfuncion.formal_param.add(subfuncion);
		 	RESULT =subfuncion;  :} 
	| VARLIST:v DOUBLE_COLON:d TBAS:t  POINT_SEMICOLON:ps FORMAL_PARAM:f {: 
			SubFuncion subfuncion= new SubFuncion();
			Simbolo simbolo= new Simbolo();
			simbolo.dosPuntos =d;
			simbolo.esDosPuntos=true;
			simbolo.tbas=t.tbas;
			simbolo.puntocoma=ps;
			simbolo.esPuntocoma=true;
			subfuncion.formal_param.add(subfuncion);
			subfuncion.formal_param.addAll(f.formal_param);
			RESULT =subfuncion;  :} ;
	
	
	//ASIGNA
	TBAS ::= NUMERIC_INTEGER_CONST:n {: 
			Simbolo simbolo= new Simbolo();
			simbolo.numericoEnteroConstante =n;
			simbolo.esNumericoEnteroConstante=true;	
			RESULT =simbolo; :}
	| NUMERIC_REAL_CONST:r {: 
			Simbolo simbolo= new Simbolo();
			simbolo.real =r;
			simbolo.esReal=true;	
			RESULT =simbolo;  :}
	;
	
	
///////////////////ASIGNA
	SENT ::= ASIG:a POINT_SEMICOLON:ps {: 
			Sentencia sentencia= new Sentencia();
			sentencia.asig=a.asig;
			sentencia.puntocoma =ps;
			sentencia.esPuntocoma=true;
			RESULT =sentencia; :}
	| PROC_CALL:p POINT_SEMICOLON:ps {: 
			Sentencia sentencia= new Sentencia();
			sentencia.proc_call=p.proc_call;
			sentencia.puntocoma =ps;
			sentencia.esPuntocoma=true;
			RESULT =sentencia;  :}
	;
	
////////////////////ASIGNA
	ASIG ::= ID:i POINT_SEMICOLON:ps EXP:e {: 
			Sentencia sentencia= new Sentencia();
			sentencia.puntocoma =ps;
			sentencia.esPuntocoma=true;
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.exp=i.exp;
			RESULT =sentencia; :}
	;
////////////////////ASIGNA
	ID ::= IDENTIFIER:i {: 
			Simbolo simbolo= new Simbolo();
			simbolo.identificador =i;
			simbolo.esIdentificador=true;
			RESULT = simbolo; :}
	;
////////////////////ASIGNA 
	EXP ::= EXP:e1 OP:o EXP:e2  {: 
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.exp.add(e1);
			subsentencia.op.add(o);
			subsentencia.exp.add(e2);
			RESULT=subsentencia;  :}
	| FACTOR:f  {: 
			SubSentencia subsentencia  = new SubSentencia();
			subsentencia.factor.add(f);
			RESULT =subsentencia; :}
	;
////////////////////ASIGNA -- rvr
	OP ::= OPARIT:o  {: 
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.op=o.op;
			RESULT =subsentencia;  :}
	;

////////////////////ASIGNA
	OPARIT ::= PLUS:p {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mas =p;
			simbolo.esMas=true;
			RESULT =simbolo; 
	:}
	| MINUS:mi  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.menos=mi;
			simbolo.esMenos=true;
			RESULT =simbolo;  
	:}
	| MULTIPLICACION:mu {:  
			Simbolo simbolo= new Simbolo();
			simbolo.multiplica =mu;
			simbolo.esMultiplica=true;
			RESULT=simbolo;
	:}
	| DIV:d  {: 
			Simbolo simbolo= new Simbolo();
			simbolo.divide =d;
			simbolo.esDivide=true;
			RESULT =simbolo;
	 :}
	| MOD:m {: 
			Simbolo simbolo= new Simbolo();
			simbolo.mod =m;
			simbolo.esMod=true;
			RESULT = simbolo;
	:}
	;
	
	
////////////////////ASIGNA 
	FACTOR ::= SIMPVALUE:s  {: 
		SubSentencia subsentencia = new SubSentencia();
		subsentencia.simpvalue=s.simpvalue;
		RESULT =subsentencia;  :}
	| OPEN_PARENTESIS:o EXP:e CLOSE_PARENTESIS:c {:
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.abreParenteis =o;
			subsentencia.esAbreParenteis=true;	
			subsentencia.cierraParentesis =c;
			subsentencia.exp= e.exp;
			subsentencia.esCierraParentesis=true;	 
			RESULT =subsentencia; :}
	| IDENTIFIER:i  SUBPARAMLIST:s  {: 
			SubSentencia subsentencia = new SubSentencia();
			subsentencia.identificador =i;
			subsentencia.esIdentificador=true;
			subsentencia.subparamLista=s.subparamLista;
			RESULT =subsentencia; 
	:}
	;
////////////////////ASIGNA
	SUBPARAMLIST ::=  OPEN_PARENTESIS:o EXPLIST:e CLOSE_PARENTESIS:c  {: 
			Sentencia sentencia= new Sentencia();
			sentencia.abreParenteis =o;
			sentencia.esAbreParenteis=true;	
			sentencia.exp=e.exp;
			sentencia.cierraParentesis =c;
			sentencia.esCierraParentesis=true;	 
			RESULT =sentencia;
		:}
		;

////////////////////ASIGNA	
	EXPLIST ::= EXP:e  {: 
			SubSentencia subsentencia= new SubSentencia();
			subsentencia.exp = e.exp;
			RESULT = subsentencia; :}
	| EXP:e SEMICOLON:s EXPLIST:ex  {: 
			SubSentencia subsentencia= new SubSentencia();	
			subsentencia.coma=s;
			subsentencia.esComa=true;
			subsentencia.exp=e.exp;
			RESULT =subsentencia;  :}
	;
	 
	PROC_CALL ::= IDENTIFIER:i SUBPARAMLIST:s {:
			Sentencia sentencia= new Sentencia();
			sentencia.identificador=i;
			sentencia.esIdentificador=true;
 			sentencia.proc_call = s.proc_call;
			RESULT =sentencia; :}
	;
	*/
	
	
